#### 需求

给6个点，做三项式拟合曲线，要求一阶导数>0。 能不能在不调用任何库的情况下，手写出来。python 语言，但是要求不调用任何库。我有一个调用`scipy`库的代码，我们当成正确结果。这个曲线拟合好之后，跟每个点都会有个误差，这个误差需要跟`scipy`的结果做对比，误差10%之内。

####  [scipy实现拟合（SLSQP 优化算法参考）.py](scipy实现拟合（SLSQP 优化算法参考）.py)

这段注释是关于MPEG WG4 VCM提案m63692的源代码的说明。该提案主要涉及使用单调曲线拟合方法改进BD-rate模型。

以下是对注释内容的详细解释：

```
# source codes of MPEG WG4 VCM proposal m63692
# Haiqiang Wang, et al., "[VCM] Improvements of the BD-rate model using monotonic
# curve-fitting method," ISO/IEC JTC 1/SC 29/WG 4, Doc. m63692，Geneva, CH – July 2023.
# contact: walleewang@tencent.com
```



- `source codes of MPEG WG4 VCM proposal m63692`：这段代码是MPEG工作组WG4下VCM（Video Coding for Machines）项目中，编号为m63692的提案的源代码。
- `Haiqiang Wang, et al.`：这个人名代表了参与编写该提案的作者团队成员之一。
- `[VCM] Improvements of the BD-rate model using monotonic curve-fitting method`：这个标题指出在VCM项目中，他们通过使用单调曲线拟合方法来改进BD率模型。BD率表示视频编码压缩算法相对于无损压缩时所引入失真程度和比特率增益之间的权衡关系。
- `ISO/IEC JTC 1/SC 29/WG 4, Doc. m63692`：ISO/IEC JTC 1/SC 29/WG 4代表国际标准化组织和电气电子工程师协会联合技术委员会第1部分第29号专题小组下WG4工作组。Doc. m63692表示该文档为编号为m63692的文件。
- `Geneva, CH – July 2023`：这里给出了地点和日期信息，指出该提案的编写地点是日内瓦，并且发布日期为2023年7月。
- `contact: walleewang@tencent.com`：这个联系信息给出了一个邮箱地址，方便人们与作者进行进一步的沟通和交流。在这里，你可以通过发送邮件到walleewang@tencent.com来联系作者。

这段代码实现了一个使用 SLSQP 算法进行曲线拟合的例子。主要分为以下几个步骤：

1. 导入必要的库：导入 numpy、scipy.optimize 中的 minimize 函数和 matplotlib.pyplot。

2. 定义三项式函数 func_cubic_2：根据给定参数 b 和 x，计算三项式函数的值，并将其与额外参数 extra 进行比较。

3. 定义拟合函数 fit_cubic：该函数用于对输入数据进行曲线拟合，并返回最优系数。在内部定义了两个辅助函数：
   - func_cubic: 根据给定参数 b 和 x，计算无偏置的三项式函数。
   - objective: 计算目标误差平方和，即预测值与真实值之间的差异。

4. 定义一阶导数约束 const_1st_derivative：根据最优系数 b，计算一阶导数并保证其大于等于零（通过 inequalities 约束类型）。

5. 初始化初始点 init，并调用 minimize 函数来求解最小化问题。方法选择 'SLSQP' 表示使用 SLSQP 算法进行优化，并传递约束条件 cons 给 constraints 参数。

6. 如果求解失败，则输出错误信息提示用户优化失败；否则返回得到的最佳系数 res.x。

7. cal_error 函数用于计算预测值与真实值之间的总误差平方和。遍历输入的 x_a 和 y_a，计算每个数据点对应的误差，并将其累加得到总误差。

8. main_loop 函数是主要的执行函数，用于调用其他函数并进行拟合和绘图操作：
   - 对 x_a 进行对数转换；
   - 调用 fit_cubic 函数对转换后的数据进行曲线拟合，并获得最佳系数 coef_a；
   - 输出最佳系数 coef_a 和六个数据点下的总误差；
   - 创建一系列点 x_plot 用于绘图，并使用拟合函数 p 计算这些点的预测值 y_plot；
   - 绘制原始数据点和拟合曲线。

9. 定义了输入数组 x_a、y_a、x_t、y_t 并调用 main_loop 函数来执行整个流程。

10. 最后输出变量 error（在代码中未被赋值）。

#### 可用算法

1.  梯度下降算法（数据太少，误差较大）
2.  SLSQP算法

####　SLSQP算法

SLSQP（Sequential Least Squares Programming）**连续最小二乘法**算法是一种优化算法，用于求解**带有约束条件**的**非线性优化**问题。它通过迭代地寻找目标函数在约束条件下的最小值。

下面是SLSQP算法的数学公式理论推导，并给出一个简单案例示范推导过程。

假设我们有一个非线性约束优化问题，目标是最小化某个函数f(x)，同时满足一组等式约束g(x) = 0和不等式约束h(x) >= 0。其中x是待求解的变量向量。

1. 线性模型近似
首先，在每次迭代中，SLSQP算法会对目标函数和约束函数进行线性近似处理。这可以通过在当前点处计算目标函数和约束函数的梯度（Jacobian矩阵）来实现。

2. 无约束最小二乘问题
  接下来，将原始非线性约束优化问题转换为一个无约束最小二乘问题。具体地说，我们引入拉格朗日乘子λ和μ来表示等式和不等式条件的惩罚项。
  定义拉格朗日函数
  $$
  L(x, λ, μ) = f(x) + λ^T * g(x) + μ^T * h(x)
  $$

  其中$^T$表示向量转置操作。

3. 迭代更新规则
  通过求解无约束最小二乘问题，我们可以得到每次迭代的更新规则。在SLSQP算法中，这个规则是由以下两个方程组给出：
  a. 一阶必要条件：
  $$
  ∇L(x, λ, μ) = ∇f(x) + J_g^T * λ + J_h^T * μ = 0
  $$
  其中$J_g$和$J_h$分别表示等式和不等式约束函数的雅可比矩阵。
  b. 约束满足性条件：$g(x) = 0$ 和$ h(x) >= 0$

4. 迭代过程
根据上述更新规则，在每次迭代中，我们需要计算目标函数、梯度、约束函数以及它们的雅可比矩阵，并使用数值优化方法（如牛顿法或拟牛顿法）来求解更新方程。

现在让我们通过一个简单案例来演示SLSQP算法的推导过程，下面将详细介绍SLSQP算法的理论推导以及如何使用该算法求解多项式参数。

SLSQP算法主要分为两个阶段：搜索阶段和修正阶段。在搜索阶段中，通过构造一个次序二次规划模型来寻找可行点；在修正阶段中，在每次迭代时进行局部搜索以获得更好的近似值，并更新当前估计点。

具体推导过程如下：

1. 初始化：选择初值 $x_0$ ，并设定停止准则。
2. 进入主循环：
   - 计算梯度向量 $\nabla f_k (x_k)$ ，其中 $k$ 表示当前迭代次数。
   - 若 $||\nabla f_k (x_k)|| < \epsilon$ ，其中 $\epsilon$ 是预设的停止准则，则停止算法并得到近似解 $x^*$ 。
   - 构造一个次序二次规划模型：
     $$
     \begin{align*}
     &\text{minimize} \quad q(x) = f_k(x) + g_k^T(x-x_k) + \frac{1}{2} (x-x_k)^T B_k (x-x_k) \\
     &\text{subject to} \quad A_{eq}(x-x_0)=0, \\
     &g_i(x)\geq 0, i=1,\ldots,m
     \end{align*}
     $$
     
      其中，$B_k$ 是正定对称矩阵，用于近似Hessian矩阵的逆；$A_{eq}$ 是等式约束的雅可比矩阵。

   - 求解上述二次规划问题，得到修正方向 $\Delta x$ 。
   - 计算步长 $\alpha$ ，使得目标函数在搜索方向上有足够下降：$\alpha = min(1, r)$ ，其中
      $$r=\max(\beta_s,r_t),$$ 
      
      $$\beta_s=\left(\frac{\partial f}{\partial x}\right)^T (\Delta x / s),$$ 

      $$r_t=\left(\frac{\partial g}{\partial x}\right)^T (\Delta x / t),$$

       其中，$s$ 和 $t$ 是正的比例因子。
   - 更新估计点：$x_{k+1} = x_k + \alpha \Delta x$
   - 返回主循环。

根据以上推导，我们可以使用SLSQP算法求解多项式参数。首先，将目标函数和约束条件表示为数学形式：

$$
f(x) = a \cdot x^3 + b \cdot x^2 + c \cdot x + d \\
g(x) = f'(x) = 3a \cdot x^2 + 2b \cdot x + c > 0
$$

然后，通过实现上述算法步骤，并设置合适的初值、停止准则、比例因子等参数进行迭代优化即可求得多项式的参数解。

通过求解上述方程组，我们可以得到当前点（即第一次迭代结果）的最优解。继续按照这个迭代过程，我们可以逐步优化目标函数，并找到满足约束条件的最优解。

##### Hessian

维基百科： https://zh.wikipedia.org/zh-hans/%E9%BB%91%E5%A1%9E%E7%9F%A9%E9%99%A3

Hessian 是优化算法中的一个重要概念，它是**目标函数的二阶导数矩阵**。在 SLSQP 算法中，Hessian 矩阵用于**估计目标函数的曲率**，从而在优化过程中确定参数的更新方向和步长。

在 SLSQP 算法中，我们希望最小化目标函数，即找到使得目标函数取得最小值的参数。通过计算目标函数的**一阶导数（梯度）和二阶导数（Hessian）**，我们可以确定目标函数在当前**参数值附近的曲率**。根据曲率的信息，我们可以决定参数的更新方向和步长，以便更快地接近最优解。

Hessian 矩阵的元素是目标函数对参数的二阶偏导数，它描述了目标函数曲面的曲率。对于一个 n 维参数空间，Hessian 矩阵是一个 n×n 的矩阵，**其中第 (i,j) 个元素表示目标函数对第 i 个参数和第 j 个参数的二阶偏导数**。

在 SLSQP 算法中，我们需要计算 Hessian 矩阵的值以及其在每次迭代中的变化。具体计算 Hessian 矩阵的方法**取决于目标函数的具体形式**。在三项式拟合的例子中，我们可以直接计算出 Hessian 矩阵的元素。

在代码示例中，我们定义了一个函数 `hessian` 来计算 Hessian 矩阵。根据三项式拟合的目标函数形式，我们可以直接计算出 Hessian 矩阵的元素。其中，hess_a_a 表示目标函数对参数 a 的二阶偏导数，hess_a_b 表示目标函数对参数 a 和 b 的二阶偏导数，依此类推。

在优化过程中，我们使用 Hessian 矩阵来决定参数的更新方向和步长。具体来说，我们使用梯度下降法的一个变种，称为 SLSQP 更新规则，来更新参数。该更新规则使用了 Hessian 矩阵的信息，通过乘以 Hessian 矩阵的逆矩阵和梯度向量来计算参数的更新量。

需要注意的是，计算 Hessian 矩阵需要对目标函数的二阶偏导数进行计算。这对于较为简单的目标函数是可行的，但对于复杂的目标函数可能会非常困难甚至不可行。在实际应用中，我们通常会使用现有的优化库（如 scipy）来自动计算目标函数的梯度和 Hessian 矩阵，以简化计算过程。

##### SLSQP算法 & 梯度下降算法

SLSQP算法和梯度下降算法是两种不同的优化算法，它们在不同的情况下可能表现得更好。

梯度下降算法是一种迭代优化方法，通过计算目标函数的梯度方向来更新参数。它适用于**连续可导**的目标函数，并且可以在**大规模数据集**上进行有效计算。然而，梯度下降算法**可能会受到局部最小值、学习率选择以及收敛速度等问题的影响。**

相比之下，SLSQP（Sequential Least Squares Programming）算法是一种约束优化方法，适用于**存在约束条件**的问题。它使用**序列二次规划**来求解问题，并且能够**处理线性和非线性约束**。SLSQP 算法通常**需要更多计算资源和时间来找到全局最优解**。SLSQP算法在面对少量数据时可能比梯度下降算法效果好的原因有以下几点：

1. 高精度：SLSQP算法是一种数值精确的优化方法，它使用序列二次规划来求解问题。相比之下，梯度下降算法是一种迭代方法，其收敛速度和最终结果受到学习率等参数选择的影响。**在处理少量数据时，SLSQP可以更准确地找到全局最优解。**

2. 约束处理：SLSQP算法适用于存在约束条件的问题，并且能够有效地处理线性和非线性约束。这使得它在需要考虑多个限制条件或复杂问题时更具优势。

3. 全局最优解：由于SLSQP采用序列二次规划方法，在搜索过程中会进行**多次迭代以寻找全局最优解**。而梯度下降通常只能保证找到局部最优解，特别是当目标函数非凸或存在平坦区域时。因此，**在面对少量数据并且希望获得全局最佳结果时，SLSQP可能会表现更好。**

因此，在选择使用哪个方法时需要考虑具体情况。如果你在无约束环境中工作并且有大量数据，则梯度下降可能更合适。而对于带有约束条件或非线性问题，则可以尝试使用 SLSQP 算法。为了确定最佳方法，**请根据实际需求进行实验比较，并根据结果选择最适合的算法**。
